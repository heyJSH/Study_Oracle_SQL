/*
[MERGE문]
 : 조건을 비교해 조건에 맞는 데이터가 없으면 INSERT,
   있으면 UPDATE를 수행하는 문장
   (쓸일이 적다)
   
[MERGE 구문]
MERGE INTO 테이블명
    USING (update나 insert 될 데이터 원천)
    ON    (update될 조건)
    
    WHEN MATCHED THEN
        UPDATE SET 컬럼1=값1, 컬럼2=값2, ...
            WHERE 조건
            DELETE WHERE 조건
    
    WHEN NOT MATCHED THEN
        INSERT(컬럼1, 컬럼2, ...) VALUES(값1, 값2, ...)
            WHERE 조건;
*/

-- MERGE 문
목표 : 2000년 10월부터 12월 사이에 월 매출을 기준으로
      적정 매출을 달성한 사원에게 더 많은 보너스를 지급함
사용 테이블 : 사원(employees), 판매(sales)

문제1. 해당월에 매출을 달성한 사원은 누구인가?
- 매출을 달성한 사원 목록을 ex3_3 테이블에 삽입
- 사원번호가 사원테이블과 판매테이블에 둘 다 있어야 함
- 2000년 10월부터 12월 사이 월 매출을 기준으로 함
      
-- 테이블 생성(102p)
DROP TABLE ex3_3;

CREATE TABLE ex3_3(
    employee_id NUMBER,
    bonus_amt   NUMBER DEFAULT 0
);

-- 2000년 10월부터 12월까지 매출 달성한 사원번호 입력
INSERT INTO ex3_3(employee_id)
    SELECT e.employee_id
    FROM employees e, sales s
    WHERE e.employee_id = s.employee_id
        AND s.SALES_MONTH BETWEEN '200010' AND '200012'
        GROUP BY e.employee_id;
        -- GROUP BY : 중복 제거
        
SELECT * FROM ex3_3
    ORDER BY employee_id;

##    ex3_3 테이블 => 매출 달성한 사원 => 보너스 받는 사람   
 1. 관리자 사번(manager_id)이 146번인 사원
 2. ex3_3 테이블에 있는 사원의 사번과 일치하면
    보너스(bonus_amt)를 자신의 급여(salary)의 1%를 보너스로 갱신
 3. ex3_3 테이블에 있는 사원의 사번과 일치하지 않으면
    1의 결과의 사원을 신규로 입력(보너스 금액은 0.1%)
    이때, 급여가 8000 미만인 사원만 처리
    
-- 1%   = salary * 0.01
-- 0.1% = salary * 0.001
    
-- ex3_3 테이블에 있는 사원의 사번, 관리자 사번, 급여, 그리고 급여*0.01을
-- 사원 테이블에서 조회
-- (보너스 1% 받는 사원의 사번, 관리자 사번, 급여, 보너스 금액 조회)
SELECT employee_id, manager_id, salary, salary*0.01
    FROM employees
    WHERE employee_id
        IN (SELECT employee_id FROM ex3_3);

-- 사원 테이블에서 관리자 사번이 146인 것 중,
-- ex3_3 테이블에 없는 사원의 사번, 관리자 사번, 급여, 급여*0.001(0.1%) 조회
-- 이중 급여가 8000 미만은 160번 사원 1명이므로
-- ex3_3 테이블의 160번 사원의 보너스 금액은 7.5로 신규 입력될 것
-- (관리자 사번 146번인 사원 중,
--  매출액 달성못한 사원의 사번, 관리자 사번, 급여, 0.1% 보너스 금액 조회)
SELECT  employee_id, manager_id, salary, salary*0.001
    FROM employees
    WHERE employee_id
        NOT IN (SELECT employee_id FROM ex3_3)
        AND manager_id = 146;

-- MERGE 문으로 작성
MERGE INTO ex3_3 d
    USING (SELECT employee_id, salary, manager_id
                FROM employees
                WHERE manager_id = 146) t
    ON (d.employee_id = t.employee_id)
    
    WHEN MATCHED THEN
        UPDATE SET d.bonus_amt = d.bonus_amt + t.salary * 0.01
        
    WHEN NOT MATCHED THEN
        INSERT (d.employee_id, d.bonus_amt)
            VALUES(t.employee_id, t.salary * 0.001)
        WHERE (t.salary < 8000);
        
SELECT *
    FROM ex3_3
    ORDER BY employee_id;
    
SELECT e.employee_id, e.manager_id, e.salary, d.bonus_amt
    FROM employees e, ex3_3 d
    WHERE e.employee_id = d.employee_id
        --AND e.manager_id = 146
    ORDER BY e.employee_id;
    
-- ex3_3 테이블의 데이터 삭제
DELETE ex3_3;
SELECT * FROM ex3_3;

-- MERGE 문에서 'UPDATE될 값을 평가해서 조건에 맞는 데이터를 삭제'
-- (DELETE WHERE d.employee_id = 161)
MERGE INTO ex3_3 d
    USING (SELECT employee_id, salary, manager_id
                FROM employees
                WHERE manager_id = 146) t
    ON (d.employee_id = t.employee_id)
    
    WHEN MATCHED THEN
        UPDATE SET d.bonus_amt = d.bonus_amt + t.salary*0.01
        DELETE WHERE (t.employee_id = 161)
    WHEN NOT MATCHED THEN
        INSERT (d.employee_id, d.bonus_amt)
            VALUES(t.employee_id, t.salary*0.001)
        WHERE t.salary < 8000;
            
SELECT *
    FROM ex3_3
    ORDER BY employee_id;
    
--==================================================================

 /*
 [DELETE 문]
 테이블에 있는 데이터를 삭제하는 문장

 [DELETE 구문]
 1. 일반구문
 DELETE [FROM] 테이블명
 WHERE 조건;

 2. 특정 파티션만 삭제할 경우의 구문
 DELETE 테이블명 PARTITION (파티션명)
 WHERE 조건;
 */

--'ex3_3'의 데이터 삭제(106p)
-- 특정 데이터 삭제
DELETE ex3_3
    WHERE employee_id = 148;
    
DELETE ex3_3
    WHERE employee_id = 155;

-- 모든 데이터 삭제
DELETE ex3_3;
-- 확인
SELECT * FROM ex3_3;

-- 파티션 조회(106p)
SELECT partition_name
    FROM user_tab_partitions
    WHERE table_name = 'SALES';


--==================================================================

/*
[COMMIT]
 - 변경한 데이터를 데이터 베이스에 최종적으로 반영
[구문]
 COMMIT [WORK] [TO SAVEPOINT 세이브포인트명];
 
[ROLLBACK]
 - 변경한 데이터를 변경 전 상태로 되돌림
[구문]
 ROLLBACK [WORK] [TO SAVEPOINT 세이브포인트명];
 
[TRUNCATE]
 - DELETE처럼 테이블 데이터를 삭제
 - 실행 시, 영구적으로 데이터가 삭제되는 DDL 문으로 WHERE 조건은 붙을 수 없다.
 - 삭제 후 ROLLBACK 불가능
[구문]
 TRUNCATE TABLE 테이블명;
*/

INSERT INTO ex3_3 VALUES(300, 100);
SELECT * FROM ex3_3;

COMMIT;

INSERT INTO ex3_3 VALUES(301, 200);
SELECT * FROM ex3_3;

ROLLBACK;
SELECT * FROM ex3_3;

--==================================================================

/*
[의사컬럼]
 - 테이블의 컬럼처럼 동작하지만 실제로 테이블에 저장되지는 않는 컬럼
 - CONNECT_BY_ISCYCLE, CONNECT_BY_ISLEAF, LEVEL
   : 계층형 쿼리에서 사용하는 의사컬럼(현재 단계에서는 생략)
 - NEXTVAL, CURRVAL
   : 시퀀스에서 사용하는 의사컬럼
 - ROWNUM, ROWID(중요)
   : ROWNUM은 쿼리에서 반환되는 각 로우에 대한 순서값(입력되는 순서값이 아님)
   : ROWID는 테이블에 저장된 각 로우가 저장된 주소값(각 로우를 식별하는 값, 유일한 값)
*/

-- 의사컬럼
-- ROWNUM, ROWID (110p)
SELECT ROWNUM, employee_id
    FROM ex3_3;

INSERT INTO ex3_3 VALUES(302, 300);
INSERT INTO ex3_3 VALUES(303, 400);
INSERT INTO ex3_3 VALUES(304, 500);
-- rownum은 실제 데이터 입력 순서와는 상관없음

SELECT ROWNUM, employee_id
    FROM ex3_3
    WHERE ROWNUM = 1;

SELECT ROWNUM, employee_id, ROWID
    FROM ex3_3
    WHERE ROWNUM < 3;
    
-- 시퀀스 의사컬럼
-- NEXTVAL, CURRVAL
DROP SEQUENCE ex3_3_seq;
CREATE SEQUENCE ex3_3_seq
    INCREMENT BY    1
    START WITH      1
    MINVALUE        1
    MAXVALUE        30
    NOCYCLE
    NOCACHE
    NOORDER; -- 요청 순서대로 값을 생성할지 여부

SELECT * FROM ex3_3;

INSERT INTO ex3_3 VALUES(ex3_3_seq.NEXTVAL, 0);

-- NEXTVAL은 조회만 하더라도 다음 번호로 넘어간다(INSERT를 하지 않아도 넘어감)
SELECT ex3_3_seq.NEXTVAL
    FROM DUAL;

SELECT ex3_3_seq.CURRVAL
    FROM DUAL;

--==================================================================

/*
[연산자]
 - 수식연산자 : +, -, *, /
 - 문자연산자 : ||
 - 논리연산자 : >, <, >=, <=, =, 
               <>, !=, ^=   : '같지 않다'는 의미
 - 집합연산자 : UNION, UNION ALL, INTERSECT, MINUS
 - 계층형 쿼리 연산자 : PRIOR, CONNECT_BY_ROOT
*/

/*
  a > b
  3 > 1 : 참(True)
  2 > 4 : 거짓(False)
  3 != 3 : 거짓(False)
*/

-- 문자연산자 => ||
SELECT emp_name || ':' || email
    FROM employees;

SELECT hire_date || '~' || RETIRE_DATE
    FROM employees;
    
-- 문자연산자 || (112p)
SELECT employee_id || '-' || emp_name AS employee_info
    FROM employees
    WHERE ROWNUM < 5;
    
-- 수식연산자 : + - * /
고객이 쇼핑몰에서 'Mouse Pad'를 3개 구매했을 때 가격 계산하기
SELECT prod_name, prod_list_price || '$', (prod_list_price *3 || '$') AS Total_Price
    FROM products
    where prod_name = 'Mouse Pad';
    
-- 수식연산자 + 문자연산자
SELECT (prod_list_price * 3 || '$') AS prod_total_price
    FROM products
    WHERE prod_name = 'Mouse Pad';
    
-- 논리연산자
고객이 쇼핑몰에서 제품을 구매할 때, 10달러 이하 제품을 검색하기
SELECT prod_name, prod_list_price
    FROM products
    WHERE prod_list_price <= 10;

--==================================================================

/*
[표현식]
 - 한 개 이상의 값과 연산자, 그리고 SQL 함수 등이 결합된 식
[CASE 표현식]
CASE WHEN 조건1 THEN 값1
     WHEN 조건2 THEN 값2
     ---
     ELSE 기타 값
END
*/

-- 문제(113p). 사원의 급여에 따라
-- 5000이하의 급여 : C, 5000~15000 : B, 15000 이상 : A등급을 반환하는 쿼리
SELECT employee_id, salary,
        CASE WHEN salary <= 5000 THEN 'C등급'
             WHEN salary BETWEEN 5000 AND 15000 THEN 'B등급'
             ELSE 'A등급'
        END AS salary_grade
    FROM employees;


-- 아래 내용에서 'D등급'은 출력X(모든 조건이 A~C 등급에 해당하므로)
SELECT employee_id, salary,
        CASE WHEN salary <= 5000 THEN 'C등급'
             WHEN salary BETWEEN 5000 AND 15000 THEN 'B등급'
             WHEN salary >= 15000 THEN 'A등급'
             ELSE 'D등급'
        END AS salary_grade
    FROM employees;